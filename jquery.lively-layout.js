/*jshint white:false, eqnull:true, immed:false, boss:true, jquery:true, forin:false */

// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  (function(jQuery) {
    /**
    * 同期for関数(ループ内で非同期処理があっても完了まで待つ)
    */

    var margin, syncEach;
    syncEach = function() {
      var args, array, cb, e, func, idx, next,
        _this = this;
      array = arguments[0], func = arguments[1], idx = arguments[2], cb = arguments[3], args = 5 <= arguments.length ? __slice.call(arguments, 4) : [];
      if (idx instanceof Function) {
        cb = idx;
        idx = 0;
      }
      if (idx >= array.length) {
        return cb.apply(array, [void 0].concat(args));
      }
      next = function() {
        var a;
        if (arguments[0] instanceof Error) {
          return cb(arguments[0]);
        }
        return syncEach.apply(_this, [array, func, idx + 1, cb].concat((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arguments.length; _i < _len; _i++) {
            a = arguments[_i];
            _results.push(a);
          }
          return _results;
        }).apply(_this, arguments)));
      };
      try {
        return func.apply(array, [array[idx], idx, next].concat(args));
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };
    /**
    * 要素のmargin-xxxの数値取得
    */

    margin = function(elem, pos) {
      var m;
      m = parseFloat(elem.css("margin-" + pos));
      if (isNaN(m)) {
        return 0;
      } else {
        return m;
      }
    };
    /**
    * $.livelyLayout()
    */

    return jQuery.livelyLayout = function(animConf, cb) {
      var $el, $html, $window, ac, pi, posInfo, _i, _len;
      if (animConf == null) {
        animConf = {};
      }
      $window = $(window);
      /* 登録されているアニメーション対象の要素の現在位置を取得*/

      posInfo = {};
      for (_i = 0, _len = animConf.length; _i < _len; _i++) {
        ac = animConf[_i];
        $el = $(ac.element);
        pi = {
          css: {
            position: $el.css('position'),
            top: $el.css('top'),
            bottom: $el.css('bottom'),
            left: $el.css('left'),
            right: $el.css('right'),
            marginTop: $el.css('margin-top'),
            marginLeft: $el.css('margin-left')
          },
          offset: {
            left: $el.offset().left - margin($el, 'left'),
            top: $el.offset().top - margin($el, 'top')
          },
          height: $el.height(),
          width: $el.width()
        };
        posInfo[ac.element] = pi;
      }
      /* 登場させる要素は一時的に画面外に配置する関係上スクロールバーが出てしまうのでhtml要素を少し改造(処理後に元に戻す)*/

      $html = $('html').css({
        width: $window.width(),
        position: 'relative',
        overflow: 'hidden'
      });
      /* アニメーション設定を1つずつ同期処理*/

      return syncEach(animConf, function(item, index, next, cssInfo) {
        var angle, animOpt, animVal, deg, elCss, elPos, _base, _base1, _base2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
        if (cssInfo == null) {
          cssInfo = [];
        }
        $el = $(item.element);
        /* 現在位置の情報を取得*/

        elPos = posInfo[item.element];
        /* 登場アニメーション時はposition:absoluteにする*/

        elCss = $.extend({}, {
          position: 'absolute',
          visibility: 'visible',
          marginTop: elPos.css.marginTop,
          marginLeft: elPos.css.marginLeft,
          left: elPos.offset.left,
          top: elPos.offset.top,
          width: elPos.width,
          height: elPos.height
        }, (_ref = item.from) != null ? _ref : {});
        /* スタートx位置特殊設定(画面外設置)*/

        if (((_ref1 = item.from) != null ? _ref1.right : void 0) < 0) {
          elCss.left = $window.width();
          elCss.right = 'auto';
        } else if (((_ref2 = item.from) != null ? _ref2.left : void 0) < 0) {
          elCss.left = elPos.width * -1;
        }
        /* スタートy位置特殊設定(画面外設置)*/

        if (((_ref3 = item.from) != null ? _ref3.bottom : void 0) < 0) {
          elCss.top = $window.height();
          elCss.bottom = 'auto';
        } else if (((_ref4 = item.from) != null ? _ref4.top : void 0) < 0) {
          elCss.top = elPos.height * -1;
        }
        /* 全処理完了後にCSSを解除する為の設定を保持*/

        cssInfo.push({
          item: item,
          css: elCss
        });
        /* 移動先は初期配置位置*/

        animVal = $.extend({}, {
          top: elPos.offset.top,
          left: elPos.offset.left
        }, (_ref5 = item.to) != null ? _ref5 : {});
        /* animate設定*/

        animOpt = {
          duration: (_ref6 = item.duration) != null ? _ref6 : 1000,
          easing: (_ref7 = item.easing) != null ? _ref7 : 'swing'
        };
        /* 完了待ち設定*/

        if (item.wait == null) {
          item.wait = true;
        }
        animOpt.complete = function() {
          var elObj, _ref8;
          elObj = $(item.element).css('transform', '');
          if ((_ref8 = item.complete) != null) {
            _ref8.call(elObj, elPos, elCss);
          }
          item.done = true;
          if (item.wait) {
            return next(cssInfo);
          }
        };
        /* 要素回転設定*/

        if (item.rotate != null) {
          if ((_base = item.rotate).rev == null) {
            _base.rev = 1;
          }
          if ((_base1 = item.rotate).type == null) {
            _base1.type = '';
          }
          if ((_base2 = item.rotate).direction == null) {
            _base2.direction = 'right';
          }
          /* durationの間に指定した回転数を満たすstep()毎の傾き算出*/

          deg = item.rotate.rev * 180 / parseInt(((_ref8 = item.duration) != null ? _ref8 : 1000) / jQuery.fx.interval, 10);
          if (item.rotate.direction === 'left') {
            deg *= -1;
          }
          angle = 0;
          animOpt.step = function() {
            angle += deg;
            return $(this).css('transform', "rotate" + item.rotate.type + "(" + angle + "deg)");
          };
        }
        /* 要素アニメーション処理実行*/

        $el.css(elCss).show();
        if (item.delay != null) {
          $el.delay(item.delay);
        }
        $el.animate(animVal, animOpt);
        /* 完了待ちしない場合はすぐに次の要素へ*/

        if (!item.wait) {
          return next(cssInfo);
        }
      }, function(err, cssInfo) {
        var timer;
        if (err != null) {
          throw new Error(err);
        }
        /* 全要素のアニメーションが完了するまで待機*/

        return timer = setInterval(function() {
          var ci, k, v, _j, _len1, _ref;
          if (((function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = cssInfo.length; _j < _len1; _j++) {
              ci = cssInfo[_j];
              if (!ci.item.done) {
                _results.push(ci);
              }
            }
            return _results;
          })()).length === 0) {
            clearInterval(timer);
            /* 一時的に変更したhtml要素のCSSを解除*/

            $html.css({
              width: '',
              position: '',
              overflow: ''
            });
            /* アニメーション用に変更した各要素のCSSを解除して素の状態に戻す*/

            for (_j = 0, _len1 = cssInfo.length; _j < _len1; _j++) {
              ci = cssInfo[_j];
              delete ci.css.visibility;
              _ref = ci.css;
              for (k in _ref) {
                v = _ref[k];
                $(ci.item.element).css(k, '');
              }
            }
            return typeof cb === "function" ? cb() : void 0;
          }
        }, 100);
      });
    };
  })(jQuery);

}).call(this);
